{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundry.js","containers/App.js","serviceWorker.js","index.js"],"names":["Card","props","name","email","id","className","src","alt","CardList","robots","map","user","i","key","SearchBox","searchfield","searchChange","type","placeholder","onChange","Scroll","style","overflowY","border","height","children","ErrorBoundry","state","hasError","error","info","this","Component","App","onSearchChange","event","setState","target","value","fetch","then","response","json","users","filteredRobots","filter","robot","toLowerCase","includes","length","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"oOA2BeA,EAdF,SAACC,GAAW,IAChBC,EAAoBD,EAApBC,KAAMC,EAAcF,EAAdE,MAAOC,EAAOH,EAAPG,GAErB,OACC,yBAAKC,UAAW,gDACf,yBAAKC,IAAG,+BAA0BF,EAA1B,YAAwCG,IAAI,WACpD,6BACC,4BAAKL,GACL,2BAAIC,MCIOK,EAtBE,SAAC,GAAc,IAAbC,EAAY,EAAZA,OAClB,OACG,6BAEAA,EAAOC,KAAI,SAACC,EAAKC,GAChB,OACC,kBAAC,EAAD,CACCC,IAAKD,EAGLR,GAAIK,EAAOG,GAAGR,GACdF,KAAMO,EAAOG,GAAGV,KAChBC,MAAOM,EAAOG,GAAGT,aCATW,EAbG,SAAC,GAAgC,EAA/BC,YAAgC,IAAnBC,EAAkB,EAAlBA,aAChC,OACC,6BACC,2BACCX,UAAU,mCACVY,KAAK,SACLC,YAAY,gBACZC,SAAUH,MCICI,EARA,SAACnB,GACf,OACC,yBAAMoB,MAAO,CAAEC,UAAW,SAAUC,OAAQ,kBAAmBC,OAAQ,UACrEvB,EAAMwB,WCeKC,E,kDApBd,WAAYzB,GAAQ,IAAD,8BAClB,cAAMA,IACD0B,MAAQ,CACZC,UAAU,GAHO,E,8DAODC,EAAOC,GACzBC,KAAKJ,MAAM,CAAEC,UAAU,M,+BAItB,OAAIG,KAAKJ,MAAMC,SACP,kEAEDG,KAAK9B,MAAMwB,a,GAhBOO,aCyDZC,G,wDA9Cd,aAAe,IAAD,8BACb,gBAiBDC,eAAiB,SAACC,GACjB,EAAKC,SAAS,CAAErB,YAAaoB,EAAME,OAAOC,SAf1C,EAAKX,MAAQ,CAEZlB,OAAQ,GACRM,YAAa,IAPD,E,gEAYO,IAAD,OACnBwB,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKP,SAAS,CAAE3B,OAAQkC,S,+BAO/B,MACwBZ,KAAKJ,MAA7BlB,EADA,EACAA,OAAQM,EADR,EACQA,YACV6B,EAAiBnC,EAAOoC,QAAO,SAAAC,GACpC,OAAOA,EAAM5C,KAAK6C,cAAcC,SAASjC,EAAYgC,kBAGrD,OAAQtC,EAAOwC,OAId,yBAAK5C,UAAU,MACf,wBAAIA,UAAU,MAAd,eACA,kBAAC,EAAD,CAAWW,aAAce,KAAKG,iBAC9B,kBAAC,EAAD,KACC,kBAAC,EAAD,KACG,kBAAC,EAAD,CAAUzB,OAAQmC,OARrB,8C,GAlCaZ,cCIEkB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCPNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACC,kBAAC,EAAD,OAEDC,SAASC,eAAe,SDoHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdC,OAAM,SAAApC,GACLqC,QAAQrC,MAAMA,EAAMsC,a","file":"static/js/main.50881959.chunk.js","sourcesContent":["import React from 'react'; //en la sintaxis anterior, esto se hacía: import React, { Component } from 'react';\r\n\r\n/*class Card extends React.Component {\r\n\trender() {\r\n\t\t// return <h1>Hello World</h1>  // muy importante, return espera solo una cosa, una linea una sola salida, entonces si se le va a dar mas de una instruccion, se debe encerrar en paréntesis igual que abajo\r\n\t\treturn ( //JSX -> react, permite escribir sintaxis SIMILAR a HTML dentro de JS, no es HTML sin parte del virutal DOM que crea react\r\n\t\t\t<div className= 'f1 tc'>\r\n\t\t\t\t<h1>Hello World</h1>\r\n\t\t\t</div>\r\n\t\t); // ver en div, que dice className, porque no class si se puede escribir como en HTML? eso es porque class es tambien un palabra reservada en JS, por eso, hay que usan className, luego ver que las clases que se agrega son 'f1 tc', son clases de Tachyons, que se importa desde el file index.js\r\n\t}\r\n}*/\r\n\r\nconst Card = (props) => {\r\n\tconst { name, email, id } = props; //esto es destructuring, a un objeto con varias elementos dentro, le asigno lo que trae el parametro, entonces el objeto toma los valores del parametro (hay que usar los mismo nombres ej. si el parametro trae props.name entonces el elemento dentro del objeto se llama name), me evita tener que usar: props.id - props.name - props.email\r\n\t// el destructuring se puede hacer tambien dentro de los parametros de la funcion -> const Card = (name, email, id) => {...\r\n\treturn (\r\n\t\t<div className= 'bg-light-green dib br3 ma2 grow bw2 shadow-5'>\r\n\t\t\t<img src={`https://robohash.org/${id}?200x200`} alt='robots' />\r\n\t\t\t<div>\r\n\t\t\t\t<h2>{name}</h2>\r\n\t\t\t\t<p>{email}</p>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t) // React introdujo en la version 16.2 el 'elemento' Fragment, para utilizar en vez de Div y con el fin de finalmente deprecar su uso\r\n}\r\n\r\nexport default Card; //se usa default, cuando solo se exporta una cosa.","import React from 'react';\r\nimport Card from './Card';\r\n\r\nconst CardList = ({robots}) => {\r\n\treturn (\r\n\t  \t<div>\r\n\t\t\t{\r\n\t\t\t\trobots.map((user,i) => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<Card \r\n\t\t\t\t\t\t\tkey={i}\r\n\t\t\t\t\t\t\t//para que sirve key? ayuda a renderizar, en caso de que se elimine un item del array por poner un ejemplo, el virtual DOM no tiene porque dibujarse de nuevo por completo, sino que con el key, React ya sabría que se removió y le ahorra trabajo\r\n\t\t\t  \t\t\t\t//la prop key debería tener algo que no cambie, ya que los items del array se mueven si se cambia el array, en este caso un mejor opcion sería id (i es para el ejemplo)\r\n\t\t\t\t\t\t\tid={robots[i].id} \r\n\t\t\t\t\t\t\tname={robots[i].name} \r\n\t\t\t\t\t\t\temail={robots[i].email} \r\n\t\t\t\t\t\t/>\r\n\t\t\t\t\t);\t\r\n\t\t\t\t})\r\n\t\t\t\t//cuando se agrega JS dentro de JS, se debe encerrar dentro de {}\r\n\t\t\t} \r\n\t  \t</div>\r\n\t);\r\n} \r\n  \r\nexport default CardList;","import React from 'react';\r\n\r\nconst SearchBox = ({searchfield, searchChange}) => {\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<input \r\n\t\t\t\tclassName='pa3 ba b--green bg-lightest-blue'\r\n\t\t\t\ttype='search' \r\n\t\t\t\tplaceholder='search robots'\r\n\t\t\t\tonChange={searchChange} \r\n\t\t\t/>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default SearchBox;","import React from 'react';\r\n\r\n//uso de children\r\n/* en app.js, Scroll está envolviendo (wrapping) al componente CardList, por lo tanto, \r\n   se convierte en un child que está dentro de los props de Scroll */\r\nconst Scroll = (props) => {\r\n\treturn ( // para los style -> recordar que esto es JSX, los estilos se pueden agregar de forma similar a HTML pero con doble {{}}\r\n\t\t< div style={{ overflowY: 'scroll', border: '1px solid black', height: '800px' }}>\r\n\t\t\t{props.children}\r\n\t\t</div>\r\n\t)\r\n};\r\n\r\nexport default Scroll;","import React, { Component } from 'react';\r\n\r\nclass ErrorBoundry extends Component {\r\n\tconstructor(props) { //esto permite el acceso a this.props en el constructor\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\thasError: false\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidCatch(error, info) {\r\n\tthis.state({ hasError: true })\r\n\t}\r\n\r\n\trender() {\r\n\t\tif (this.state.hasError) {\r\n\t\t\treturn <h1>Oooops!! That does not look good!!</h1>\r\n\t\t}\r\n\t\treturn this.props.children\r\n\t}\r\n}\r\n\r\n\r\nexport default ErrorBoundry;","import React, { Component } from 'react';\r\nimport CardList from '../components/CardList';\r\n//import { robots } from './robots'; // para imports hechos de exports que no usan default, la regla es desestructurarlos { }\r\nimport SearchBox from '../components/SearchBox';\r\nimport Scroll from '../components/Scroll';\r\nimport ErrorBoundry from '../components/ErrorBoundry';\r\nimport './App.css';\r\n\r\nclass App extends Component {\r\n\t/*tengo el componente App, que tiene dos 'states' (robots y searchfield), como App es el dueño de state, cualquier componente que tiene\r\n\t  'state' usa la sintaxis 'class' y así pueden usar la función constructor para creat this.state\r\n\t   y \"state\" es lo que cambia en un app, es lo que describe una app.*/\r\n\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\t//this.state dentro del constructor, this.setState no.\r\n\t\t//this.state es un trigger, que indica que en cuanto cambie lo que esta ahi, actúe de acuerdo  a lo descrito en lo demás métodos\r\n\t\tthis.state = { // state se define como algo que puede cambiar y afectar la aplicación\r\n\t\t\t//robots: robots, // claramente robots es un array que no cambia, pero se pone aca para ejemplificar, no siempre lo que se tienen que actualizar va a ser un array de un tamaño definidido\r\n\t\t\trobots: [],\r\n\t\t\tsearchfield: ''\r\n\t\t}\r\n\t}\r\n\t\r\n\t// ver: https://es.reactjs.org/docs/react-component.html#componentdidmount\r\n\tcomponentDidMount() {\r\n\t\tfetch('https://jsonplaceholder.typicode.com/users') //fecth es parte del objeto window, es una herramienta para poder hacer requests a un servidor\r\n\t\t.then(response => response.json())\r\n\t\t.then(users => this.setState({ robots: users}))\r\n\t}\r\n\r\n\tonSearchChange = (event) => { //porque usando = y => ? bueno es solo una regla de react que se usa cuando se crean los metodos propios, sintaxis de react, por lo que solo hay que seguirla siempre\r\n\t\tthis.setState({ searchfield: event.target.value }) //otro metodo de react, cada vez que se quiere cambiar state, se hacer por medio de this.setState\r\n\t}\r\n\r\n\trender() { // notar que las funciones que son parte de react, no llevan = y =>\r\n\t\tconst { robots, searchfield } = this.state;\r\n\t\tconst filteredRobots = robots.filter(robot => {\r\n\t\t\treturn robot.name.toLowerCase().includes(searchfield.toLowerCase());\r\n\t\t})\r\n\r\n\t\t\treturn !robots.length  ? // \"!robots.length\" es lo mismo que decir \"robots.length === 0\"\r\n\t\t\t\t <h1>Loading...</h1>\r\n\t\t\t:\r\n\t\t\t(\r\n\t\t\t\t<div className='tc'>\r\n\t\t\t\t<h1 className='f1'>RoboFriends</h1>\r\n\t\t\t\t<SearchBox searchChange={this.onSearchChange}/>\r\n\t\t\t\t<Scroll>\r\n\t\t\t\t\t<ErrorBoundry>\r\n\t\t\t  \t\t\t<CardList robots={filteredRobots}/>\r\n\t\t\t  \t\t</ErrorBoundry>\r\n\t\t\t  \t</Scroll>\r\n\t\t\t  \t</div>\r\n\t\t\t);\r\n\t\t\r\n\t} //recordar que los custom components (creados por uno mismo) se declaran con mayúscula, para diferenciarlos\r\n}\r\n\r\nexport default App;\r\n\r\n/*\r\n¿Qué hace setState?\r\nsetState() programa una actualización al objeto estado de un componente. \r\nCuando el estado cambia, el componente responde volviendo a renderizar.\r\n\r\n¿Cuál es la diferencia entre state y props?\r\nprops (abreviatura de ”properties”) y state son objetos planos de JavaScript. Mientras ambos contienen información \r\nque influye en el resultado del render, son diferentes debido a una importante razón: props se pasa al componente \r\n(similar a los parámetros de una función) mientras que state se administra dentro del componente \r\n(similar a las variables declaradas dentro de una función).\r\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'; // paquete CORE que hace el DOM manipulation por nosotros, react se puede usar en multiples dispositivos, no solo en browser, incluso en dispositivos de VR\nimport ReactDOM from 'react-dom'; // se usan para renderizar basado en el dispositivo y su tamaño\nimport './index.css'; // nueva sintaxis, de esta forma utiliza el CSS que renderiza, en este caso hay un css solo para index, la diferencia es que solo se usa import y el nombre del file, a diferencia de React y ReactDOM por poner ejemplos, que usan 'from' para indicar de donde se llama. La sintaxis ./ indica que está en el mismo directorio\n//import Hello from './Hello'; // ./Hello es un archivo js que vive en el mismo directorio que este file, con esta sintaxis, no es necesario poder el .js ya que automaticamente se asume\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker'; //no se ve en este curso pero es basicamente para que la página sea más rápida y pueda potencialmente trabajar offline\nimport 'tachyons';\n\n// en tanto los imports de arriba se mantengan como están, en la parte superior del file, de primeros\n// se pueden agregar cuantos files o paquetes sea necesario\n\nReactDOM.render(\n  <React.StrictMode>\n  \t<App />\n  </React.StrictMode>,\n  document.getElementById('root')\n); //notar que despues del componente Hello, agrego algo mas, es un prop (propiedad), las cuales pueden tener atributos, y se pueden mandar a llamar dentro del file del componente\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}